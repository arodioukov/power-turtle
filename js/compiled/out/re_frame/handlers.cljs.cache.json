["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$re-frame.handlers","~:imports",null,"~:requires",["^ ","~$re-frame.db","^;","~$re-frame.utils","^<"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$app-db","^;","~$warn","^<","~$first-in-vector","^<","~$error","^<"],"~:defs",["^ ","~$report-middleware-factories",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/timothy/git/power-turtle/resources/public/js/compiled/out/re_frame/handlers.cljs","~:line",9,"~:column",7,"~:end-line",9,"~:end-column",34,"~:arglists",["~#list",["~$quote",["^M",[["~$v"]]]]],"~:doc","See https://github.com/Day8/re-frame/issues/65"],"^7","~$re-frame.handlers/report-middleware-factories","~:variadic",false,"^G","resources/public/js/compiled/out/re_frame/handlers.cljs","^K",34,"~:method-params",["^M",[["~$v"]]],"~:protocol-impl",null,"~:arglists-meta",["^M",[null,null]],"^I",1,"^H",9,"^J",9,"~:max-fixed-arity",1,"~:fn-var",true,"^L",["^M",["^N",["^M",[["~$v"]]]]],"^O","See https://github.com/Day8/re-frame/issues/65"],"~$comp-middleware",["^ ","^E",null,"^F",["^ ","^G","/home/timothy/git/power-turtle/resources/public/js/compiled/out/re_frame/handlers.cljs","^H",22,"^I",7,"^J",22,"^K",22,"^L",["^M",["^N",["^M",[["~$v"]]]]],"^O","Given a vector of middleware, filter out any nils, and use \"comp\" to compose the elements.\n  v can have nested vectors, and will be flattened before \"comp\" is applied.\n  For convienience, if v is a function (assumed to be middleware already), just return it.\n  Filtering out nils allows us to create Middleware conditionally like this:\n     (comp-middleware [pure (when debug? debug)])  ;; that 'when' might leave a nil\n  "],"^7","~$re-frame.handlers/comp-middleware","^Q",false,"^G","resources/public/js/compiled/out/re_frame/handlers.cljs","^K",22,"^R",["^M",[["~$v"]]],"^S",null,"^T",["^M",[null,null]],"^I",1,"^H",22,"^J",22,"^U",1,"^V",true,"^L",["^M",["^N",["^M",[["~$v"]]]]],"^O","Given a vector of middleware, filter out any nils, and use \"comp\" to compose the elements.\n  v can have nested vectors, and will be flattened before \"comp\" is applied.\n  For convienience, if v is a function (assumed to be middleware already), just return it.\n  Filtering out nils allows us to create Middleware conditionally like this:\n     (comp-middleware [pure (when debug? debug)])  ;; that 'when' might leave a nil\n  "],"~$id->fn",["^ ","^7","~$re-frame.handlers/id->fn","^G","resources/public/js/compiled/out/re_frame/handlers.cljs","^H",41,"^I",1,"^J",41,"^K",22,"~:private",true,"^F",["^ ","^G","/home/timothy/git/power-turtle/resources/public/js/compiled/out/re_frame/handlers.cljs","^H",41,"^I",16,"^J",41,"^K",22,"^[",true],"~:tag","~$any"],"~$lookup-handler",["^ ","^E",null,"^F",["^ ","^G","/home/timothy/git/power-turtle/resources/public/js/compiled/out/re_frame/handlers.cljs","^H",44,"^I",7,"^J",44,"^K",21,"^L",["^M",["^N",["^M",[["~$event-id"]]]]]],"^7","~$re-frame.handlers/lookup-handler","^Q",false,"^G","resources/public/js/compiled/out/re_frame/handlers.cljs","^K",21,"^R",["^M",[["^13"]]],"^S",null,"^T",["^M",[null,null]],"^I",1,"^H",44,"^J",44,"^U",1,"^V",true,"^L",["^M",["^N",["^M",[["^13"]]]]]],"~$clear-handlers!",["^ ","^E",null,"^F",["^ ","^G","/home/timothy/git/power-turtle/resources/public/js/compiled/out/re_frame/handlers.cljs","^H",49,"^I",7,"^J",49,"^K",22,"^L",["^M",["^N",["^M",[[]]]]],"^O","Unregister all event handlers"],"^7","~$re-frame.handlers/clear-handlers!","^Q",false,"^G","resources/public/js/compiled/out/re_frame/handlers.cljs","^K",22,"^R",["^M",[[]]],"^S",null,"^T",["^M",[null,null]],"^I",1,"^H",49,"^J",49,"^U",0,"^V",true,"^L",["^M",["^N",["^M",[[]]]]],"^O","Unregister all event handlers"],"~$register-base",["^ ","^E",null,"^F",["^ ","^G","/home/timothy/git/power-turtle/resources/public/js/compiled/out/re_frame/handlers.cljs","^H",55,"^I",7,"^J",55,"^K",20,"^L",["^M",["^N",["^M",[["^13","~$handler-fn"],["^13","~$middleware","^18"]]]]],"^O","register a handler for an event.\n  This is low level and it is expected that \"re-frame.core/register-handler\" would\n  generally be used.","~:top-fn",["^ ","^Q",false,"^U",3,"^R",["^M",[["^13","^18"],["^13","^19","^18"]]],"^L",["^M",[["^13","^18"],["^13","^19","^18"]]],"^T",["^M",[null,null]]]],"^7","~$re-frame.handlers/register-base","^Q",false,"^G","resources/public/js/compiled/out/re_frame/handlers.cljs","^K",20,"^1:",["^ ","^Q",false,"^U",3,"^R",["^M",[["^13","^18"],["^13","^19","^18"]]],"^L",["^M",[["^13","^18"],["^13","^19","^18"]]],"^T",["^M",[null,null]]],"^R",["^M",[["^13","^18"],["^13","^19","^18"]]],"^S",null,"^T",["^M",[null,null]],"^I",1,"^H",55,"^J",55,"^U",3,"^V",true,"^L",["^M",[["^13","^18"],["^13","^19","^18"]]],"^O","register a handler for an event.\n  This is low level and it is expected that \"re-frame.core/register-handler\" would\n  generally be used."],"~$*handling*",["^ ","^7","~$re-frame.handlers/*handling*","^G","resources/public/js/compiled/out/re_frame/handlers.cljs","^H",74,"^I",1,"^J",74,"^K",26,"~:dynamic",true,"^F",["^ ","^G","/home/timothy/git/power-turtle/resources/public/js/compiled/out/re_frame/handlers.cljs","^H",74,"^I",16,"^J",74,"^K",26,"^1>",true],"^10","~$clj-nil"],"~$handle",["^ ","^E",null,"^F",["^ ","^G","/home/timothy/git/power-turtle/resources/public/js/compiled/out/re_frame/handlers.cljs","^H",77,"^I",7,"^J",77,"^K",13,"^L",["^M",["^N",["^M",[["~$event-v"]]]]],"^O","Given an event vector, look up the handler, then call it.\n  By default, handlers are not assumed to be pure. They are called with\n  two paramters:\n    - the `app-db` atom\n    - the event vector\n  The handler is assumed to side-effect on `app-db` - the return value is ignored.\n  To write a pure handler, use the \"pure\" middleware when registering the handler."],"^7","~$re-frame.handlers/handle","^Q",false,"^G","resources/public/js/compiled/out/re_frame/handlers.cljs","^K",13,"^R",["^M",[["^1A"]]],"^S",null,"^T",["^M",[null,null]],"^I",1,"^H",77,"^J",77,"^U",1,"^V",true,"^L",["^M",["^N",["^M",[["^1A"]]]]],"^O","Given an event vector, look up the handler, then call it.\n  By default, handlers are not assumed to be pure. They are called with\n  two paramters:\n    - the `app-db` atom\n    - the event vector\n  The handler is assumed to side-effect on `app-db` - the return value is ignored.\n  To write a pure handler, use the \"pure\" middleware when registering the handler."]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~:re-frame-factory-name","~:else"]],"~:order",["^1G","^1H"]],"^O",null]